<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Calculus Lab with Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* ==================== GLOBAL STYLES ==================== */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', sans-serif; 
        }
        
        /* ==================== LEFT PANEL (VISUAL CONTROLS) ==================== */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(15, 15, 15, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
            z-index: 100;
        }

        #ui.minimized {
            transform: translateX(-350px);
            opacity: 0.5;
        }

        #minimize-btn {
            position: absolute;
            right: -40px;
            top: 0;
            width: 30px;
            height: 30px;
            background: rgba(15, 15, 15, 0.9);
            border: 1px solid #444;
            border-radius: 0 6px 6px 0;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* ==================== RIGHT PANEL (FUNCTION & INTEGRAL) ==================== */
        #ui-right {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(15, 15, 15, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
        }

        #ui-right.minimized {
            transform: translateX(350px);
            opacity: 0.5;
        }

        #minimize-btn-right {
            position: absolute;
            left: -40px; /* place the button outside the panel on its left edge */
            top: 0;
            width: 30px;
            height: 30px;
            background: rgba(15, 15, 15, 0.9);
            border: 1px solid #444;
            border-radius: 0 6px 6px 0; /* rounded on the right side so it visually attaches to panel */
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 110; /* ensure it's above nearby UI */
        }

        /* Hamburger toggle for the right panel */
        #ui-right-hamburger {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 36px;
            height: 36px;
            background: rgba(20,20,20,0.95);
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 120;
            font-size: 18px;
        }

        /* ==================== BOTTOM CONSOLE PANEL ==================== */
        #console-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            color: white;
            background: rgba(20, 20, 20, 0.98);
            border-top: 1px solid #444;
            z-index: 90;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            max-height: 40vh;
        }

        #console-panel.minimized {
            transform: translateY(calc(100% - 40px));
        }

        .console-header {
            padding: 8px 15px;
            background: rgba(30, 30, 30, 0.95);
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .console-header h3 {
            margin: 0;
            color: #ffaa44;
            font-size: 0.9em;
            font-weight: 600;
        }

        #minimize-btn-console {
            background: rgba(15, 15, 15, 0.9);
            border: 1px solid #444;
            border-radius: 4px;
            color: white;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
        }

        .console-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 15px;
            gap: 15px;
        }

        .console-section {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            border-right: 1px solid #333;
            padding-right: 15px;
        }

        .console-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .console-section h4 {
            margin: 0 0 10px 0;
            color: #ccc;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ==================== FORM ELEMENTS ==================== */
        .input-group { 
            margin-bottom: 12px; 
        }
        
        label { 
            display: block; 
            font-size: 0.75em; 
            color: #aaa; 
            margin-bottom: 5px; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
        }
        
        input, select {
            width: 100%;
            background: #222;
            border: 1px solid #444;
            color: #0f0;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box;
        }
        
        /* ==================== BUTTONS & MODES ==================== */
        .btn-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 8px; 
            margin-top: 10px; 
        }
        
        button.mode-btn {
            padding: 8px;
            cursor: pointer;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        
        button.mode-btn:hover { 
            background: #444; 
        }
        
        button.mode-btn.active { 
            background: #2563eb; 
            border-color: #3b82f6; 
        }
        
        /* ==================== DISPLAY & LEGEND ==================== */
        #math-display {
            margin-top: 15px;
            padding: 10px;
            background: #000;
            border-radius: 4px;
            font-size: 0.85em;
            border-left: 3px solid #2563eb;
        }
        
        .legend { 
            font-size: 0.7em; 
            margin-top: 10px; 
            opacity: 0.8; 
            line-height: 1.4; 
        }
        
        .key { 
            border: 1px solid #666; 
            padding: 1px 4px; 
            border-radius: 3px; 
            font-size: 0.8em; 
        }
        
        /* ==================== CANVAS & MINIMAP ==================== */
        canvas { 
            display: block; 
            cursor: grab; 
        }
        
        canvas:active { 
            cursor: grabbing; 
        }

        #minimap {
            position: absolute;
            bottom: 50px;
            right: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #000;
            z-index: 99;
            cursor: grab;
        }

        /* ==================== CONSOLE SPECIFIC STYLES ==================== */
        .eval-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .eval-controls input {
            flex: 1;
            text-align: center;
            padding: 6px;
            font-size: 0.85em;
        }

        .eval-controls button {
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85em;
            white-space: nowrap;
        }

        .results-container {
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
        }

        .calc-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .calc-btn {
            padding: 6px 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
            text-align: center;
        }

        .calc-btn:hover {
            background: #444;
            border-color: #666;
        }

        .calc-btn:active {
            background: #2563eb;
            border-color: #3b82f6;
        }

        .console-entry {
            margin-bottom: 4px;
            padding: 4px 6px;
            border-left: 2px solid #2563eb;
            background: rgba(255,255,255,0.05);
            border-radius: 0 4px 4px 0;
            font-size: 0.85em;
        }

        .console-entry:last-child {
            margin-bottom: 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.8em;
        }

        .stat-item {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .stat-label {
            color: #aaa;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .stat-value {
            color: #4ade80;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* ==================== RESPONSIVE ADJUSTMENTS ==================== */
        @media (max-width: 1200px) {
            .console-content {
                flex-wrap: wrap;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .console-section {
                flex: 1 1 45%;
                min-width: 200px;
                margin-bottom: 10px;
                border-right: none;
                border-bottom: 1px solid #333;
                padding-right: 0;
                padding-bottom: 10px;
            }
            
            .console-section:last-child {
                border-bottom: none;
            }
        }

        /* ==================== SCROLLBAR STYLING ==================== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <button id="ui-right-hamburger" title="Toggle Function Panel">☰</button>

    <div id="ui">
        <button id="minimize-btn" title="Toggle UI">M</button>
        <h3 style="margin: 0 0 15px 0; color: #2563eb;">Visual Controls</h3>
        
        <div class="input-group">
            <label>VISUAL CONTROLS</label>
            <div style="display:grid; gap:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:0.85em; color:#9ca3af;">Triple Resolution</span>
                    <input id="tripleRes" type="range" min="8" max="64" step="1" value="24" style="width:140px;">
                    <span id="tripleResVal" style="width:30px; text-align:right; color:#cbd5e1;">24</span>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:0.85em; color:#9ca3af;">Particle Size</span>
                    <input id="particleSize" type="range" min="0.04" max="0.3" step="0.01" value="0.08" style="width:140px;">
                    <span id="particleSizeVal" style="width:30px; text-align:right; color:#cbd5e1;">0.08</span>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:0.85em; color:#9ca3af;">Particle Opacity</span>
                    <input id="particleOpacity" type="range" min="0.1" max="1" step="0.05" value="0.6" style="width:140px;">
                    <span id="particleOpacityVal" style="width:30px; text-align:right; color:#cbd5e1;">0.60</span>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:0.85em; color:#9ca3af;">Shell Speed</span>
                    <input id="shellSpeed" type="range" min="0.01" max="0.25" step="0.01" value="0.05" style="width:140px;">
                    <span id="shellSpeedVal" style="width:30px; text-align:right; color:#cbd5e1;">0.05</span>
                </div>
            <div style="display:grid; gap:8px;">
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="shellAuto" type="checkbox" checked style="width:16px; height:16px; flex-shrink:0;">
                    <label for="shellAuto" style="font-size:0.85em; color:#9ca3af; margin:0;">Auto-animate Shells</label>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="cameraLock2D" type="checkbox" style="width:16px; height:16px; flex-shrink:0;">
                    <label for="cameraLock2D" style="font-size:0.85em; color:#9ca3af; margin:0;">Camera Lock 2D (Top)</label>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="cameraLockFront" type="checkbox" style="width:16px; height:16px; flex-shrink:0;">
                    <label for="cameraLockFront" style="font-size:0.85em; color:#9ca3af; margin:0;">Camera Lock Front</label>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="cameraLockSide" type="checkbox" style="width:16px; height:16px; flex-shrink:0;">
                    <label for="cameraLockSide" style="font-size:0.85em; color:#9ca3af; margin:0;">Camera Lock Side</label>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="cameraMouseEnable" type="checkbox" checked style="width:16px; height:16px; flex-shrink:0;">
                    <label for="cameraMouseEnable" style="font-size:0.85em; color:#9ca3af; margin:0;">Enable Mouse Camera</label>
                </div>
            </div>
            </div>
        </div>

        <div class="legend">
            <p><span class="key">Drag</span> Orbit | <span class="key">Scroll</span> Zoom</p>
            <div style="color: #ff4444">X Axis | <span style="color: #4444ff">Z Axis</span> (Inputs)</div>
            <div style="color: #44ff44">Y Axis (Function Value/Volume)</div>
        </div>
    </div>

    <div id="ui-right">
        <button id="minimize-btn-right" title="Toggle UI">M</button>
        <h3 style="margin: 0 0 15px 0; color: #2563eb;">Function & Integral</h3>
        <div class="input-group" style="margin-bottom:10px;">
            <label>Panel Setting</label>
            <div style="display:flex; gap:8px; align-items:center;">
                <select id="uiRightDefault" style="width:160px; background:#222; color:#4ade80; border:1px solid #444; padding:6px; border-radius:4px;">
                    <option value="open">Open by default</option>
                    <option value="closed">Closed by default</option>
                </select>
                <button id="saveUiRightPref" class="mode-btn" style="padding:6px;">Save</button>
            </div>
        </div>
        
        <div class="input-group">
            <label>FUNCTION f(x, z)</label>
            <input type="text" id="funcInput" value="Math.cos(x)*Math.sin(z)*2" spellcheck="false">
        </div>

        <div class="btn-grid">
            <button id="btnNormal" class="mode-btn active">Surface f(x,z)</button>
            <button id="btnDeriv" class="mode-btn">Partial ∂f/∂x</button>
            <button id="btnDouble" class="mode-btn">Double ∫∫</button>
            <button id="btnTriple" class="mode-btn">Triple ∫∫∫</button>
            <button id="btnShell" class="mode-btn">Shell Method</button>
        </div>

        <div id="math-display">
            <strong>Logic:</strong> <span id="logicText">Showing Surface</span>
            <div id="formula" style="color: #4ade80; margin-top: 5px; font-family: serif; font-style: italic;">y = f(x, z)</div>
        </div>

        <div class="input-group">
            <label>PRESETS</label>
            <select id="presetSelect" style="width: 100%; background: #222; color: #4ade80; border: 1px solid #444; padding: 8px; border-radius: 4px;">
                <option value="">-- Choose a Shape --</option>
                <option value="Math.cos(Math.sqrt(x*x + z*z)) * 2">The Ripple (Polar Wave)</option>
                <option value="Math.exp(-(x*x + z*z) / 10) * 8">The Bell Curve (Gaussian)</option>
                <option value="(x*x - z*z) / 4">The Saddle (Hyperbolic)</option>
                <option value="Math.sin(x) * Math.cos(z) * 3">Egg Crate</option>
                <option value="Math.abs(x)">The Cone (Best for Shells)</option>
                <option value="Math.sqrt(Math.max(0, 25 - (x*x + z*z)))">The Hemisphere</option>
                <option value="Math.sin(x) * Math.sin(z) * 3">Wave Interference</option>
                <option value="Math.exp(-0.1*(x*x + z*z)) * Math.cos(2*Math.sqrt(x*x + z*z))">Damped Oscillation</option>
                <option value="Math.sqrt(x*x + z*z) / 2">The Cone Smooth</option>
                <option value="Math.sin(x)*Math.cos(z) + Math.cos(x)*Math.sin(z)">Sine Product Sum</option>
                <option value="(x*x + z*z) / 10">Paraboloid</option>
                <option value="Math.tanh(x) * Math.tanh(z) * 3">Smooth Step</option>
                <option value="Math.sin(x*z) * 2">Cross Sine</option>
                <option value="1 / (0.5 + x*x + z*z)">Gaussian Peak</option>
                <option value="Math.cos(x) + Math.sin(z)">Simple Wave</option>
                <option value="Math.max(0, 4 - Math.abs(x) - Math.abs(z))">Pyramid</option>
            </select>
            <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                <div style="flex:1; text-align:left; color:#9ca3af; font-size:0.8em;">Choose then click</div>
                <button id="loadPresetBtn" class="mode-btn" style="padding:6px; font-size:0.82em;">Load Preset</button>
            </div>
            <div id="status" style="transition:opacity 240ms; opacity:0; font-size:0.82em; color:#a3e635; margin-top:6px;">&nbsp;</div>
        </div>
    </div>

    <!-- Bottom Console Panel -->
    <div id="console-panel">
        <div class="console-header">
            <h3>Math Console</h3>
            <button id="minimize-btn-console" title="Toggle Console">▼</button>
        </div>
        
        <div class="console-content">
            <!-- Left Section: Evaluation -->
            <div class="console-section">
                <h4>Quick Evaluation</h4>
                <div class="eval-controls">
                    <input type="text" id="console-x" placeholder="x" value="1.5">
                    <input type="text" id="console-z" placeholder="z" value="1.0">
                    <button id="eval-btn">Evaluate</button>
                </div>
                
                <h4 style="margin-top: 15px;">Results</h4>
                <div class="results-container" id="console-results">
                    <div class="console-entry">
                        <span style="color: #4ade80;">f(1.5, 1.0)</span>
                        <span style="color: #ccc;">= </span>
                        <span style="color: #ffaa44;">2.137</span>
                    </div>
                </div>
            </div>
            
            <!-- Middle Section: Calculations -->
            <div class="console-section">
                <h4>Calculations</h4>
                <div class="calc-grid">
                    <button id="calc-derivative" class="calc-btn">∂f/∂x</button>
                    <button id="calc-derivative-z" class="calc-btn">∂f/∂z</button>
                    <button id="calc-gradient" class="calc-btn">∇f</button>
                    <button id="calc-double-int" class="calc-btn">∬ f dxdz</button>
                    <button id="calc-triple-int" class="calc-btn">∭ f dV</button>
                    <button id="calc-volume" class="calc-btn">Volume</button>
                </div>
                
                <h4 style="margin-top: 15px;">Actions</h4>
                <div style="display: flex; gap: 8px;">
                    <button id="clear-results" class="calc-btn" style="flex: 1;">Clear Results</button>
                    <button id="export-data" class="calc-btn" style="flex: 1;">Export Data</button>
                </div>
            </div>
            
            <!-- Right Section: Statistics -->
            <div class="console-section">
                <h4>Statistics</h4>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Domain X</div>
                        <div class="stat-value" id="domain-x">[-10, 10]</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Domain Z</div>
                        <div class="stat-value" id="domain-z">[-10, 10]</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Min Value</div>
                        <div class="stat-value" id="min-value">-2.34</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Max Value</div>
                        <div class="stat-value" id="max-value">3.45</div>
                    </div>
                    <div class="stat-item" style="grid-column: span 2;">
                        <div class="stat-label">Average Value</div>
                        <div class="stat-value" id="avg-value">0.78</div>
                    </div>
                </div>
                
                <h4 style="margin-top: 15px;">Function Info</h4>
                <div style="font-size: 0.8em; color: #aaa; line-height: 1.4;">
                    <div>Current: <span id="current-func" style="color: #4ade80; font-family: monospace;">cos(x)*sin(z)*2</span></div>
                    <div>Mode: <span id="current-mode" style="color: #60a5fa;">Surface</span></div>
                    <div>Samples: <span id="sample-count" style="color: #f59e0b;">2500</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Minimap (positioned above console) -->
    <div style="position: absolute; bottom: 50px; right: 20px; display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
        <button id="minimapToggle" style="width: 30px; height: 24px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.7em; font-weight: bold; padding: 2px;">2D Map</button>
        <canvas id="minimap" width="200" height="200"></canvas>
    </div>

    <script>
        // ========================================
        // 3D CALCULUS LAB - INTERACTIVE VISUALIZATION
        // With Bottom Console Panel
        // ========================================

        // ==================== GLOBAL STATE ====================
        let scene, camera, renderer, graphObject, volumeObject;
        let theta = Math.PI / 4, phi = Math.PI / 3, radius = 25;
        const keys = {};
        let currentMode = 'normal';
        let minimapMode = 'heatmap';
        let isMouseDown = false;
        let prevMouseX = 0, prevMouseY = 0;
        let sweepAngle = 0;
        let statusTimer = null;
        let evalHistory = [];
        let consoleMinimized = false;
        let mouseCameraEnabled = true; // toggles camera rotation via mouse drag
        let isDraggingMinimap = false;
        let minimapDragOffsetX = 0, minimapDragOffsetY = 0;

        // ==================== MAIN INITIALIZATION ====================
        function init() {
            // Setup scene, camera, and renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Add visual helpers
            scene.add(new THREE.GridHelper(30, 30, 0x333333, 0x222222));
            scene.add(new THREE.AxesHelper(15));

            // Setup lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            scene.add(sun);

            // Register event listeners
            setupEventListeners();

            // Wire up UI controls
            setupUIControls();

            // Initialize console
            initConsole();

            // Initial render
            updateGraph();
            updateCamera();
            drawMinimap();
            animate();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => keys[e.code] = true);
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onWheel, { passive: false });
        }

        function setupUIControls() {
            // Setup minimap dragging
            setupMinimapDragging();
            // Setup hamburger toggle for right panel and preference
            setupHamburgerToggle();

            // Function input and preset sync
            const funcInput = document.getElementById('funcInput');
            const preset = document.getElementById('presetSelect');

            if (funcInput) {
                funcInput.addEventListener('input', () => { 
                    updateGraph(); 
                    syncPresetSelection(); 
                });
            }

            if (preset) {
                preset.addEventListener('change', (e) => {
                    const v = e.target.value;
                    if (v) {
                        funcInput.value = v;
                        updateGraph();
                        showStatus('Preset applied: ' + preset.options[preset.selectedIndex].text);
                    }
                });
            }

            const loadBtn = document.getElementById('loadPresetBtn');
            if (loadBtn && preset) {
                loadBtn.onclick = () => {
                    const v = preset.value;
                    const label = preset.options[preset.selectedIndex]?.text || '';
                    if (v) {
                        if (confirm(`Load preset "${label}" into the function input?`)) {
                            funcInput.value = v;
                            updateGraph();
                            showStatus('Loaded preset: ' + label);
                        } else {
                            showStatus('Load canceled');
                        }
                    }
                };
            }

            syncPresetSelection();

            // Visualization control sliders
            setupSlider('tripleRes', 'tripleResVal', () => updateGraph());
            setupSlider('particleSize', 'particleSizeVal', () => updateGraph(), true);
            setupSlider('particleOpacity', 'particleOpacityVal', () => updateGraph(), true);
            setupSlider('shellSpeed', 'shellSpeedVal', () => {});

            // Camera lock checkboxes - make them mutually exclusive
            const cameraCheckboxes = ['cameraLock2D', 'cameraLockFront', 'cameraLockSide'];
            cameraCheckboxes.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            cameraCheckboxes.forEach(otherId => {
                                if (otherId !== id) {
                                    const otherEl = document.getElementById(otherId);
                                    if (otherEl) otherEl.checked = false;
                                }
                            });
                        }
                        updateCamera();
                    });
                }
            });

            // Mouse camera enable/disable
            const mouseCamEl = document.getElementById('cameraMouseEnable');
            if (mouseCamEl) {
                // initialize from localStorage
                const saved = localStorage.getItem('cameraMouseEnabled');
                if (saved !== null) {
                    const val = saved === 'true';
                    mouseCamEl.checked = val;
                    mouseCameraEnabled = val;
                } else {
                    mouseCamEl.checked = mouseCameraEnabled;
                }

                mouseCamEl.addEventListener('change', (e) => {
                    mouseCameraEnabled = !!e.target.checked;
                    localStorage.setItem('cameraMouseEnabled', mouseCameraEnabled ? 'true' : 'false');
                    showStatus('Mouse camera ' + (mouseCameraEnabled ? 'enabled' : 'disabled'), 1200);
                });
            }

            // Mode buttons
            document.getElementById('btnNormal').onclick = () => setMode('normal');
            document.getElementById('btnDeriv').onclick = () => setMode('deriv');
            document.getElementById('btnDouble').onclick = () => setMode('double');
            document.getElementById('btnTriple').onclick = () => setMode('triple');
            document.getElementById('btnShell').onclick = () => setMode('shell');

            // Panel minimize buttons
            const ui = document.getElementById('ui');
            const minBtn = document.getElementById('minimize-btn');
            minBtn.onclick = () => {
                ui.classList.toggle('minimized');
                minBtn.textContent = ui.classList.contains('minimized') ? "➔" : "M";
            };

            const uiRight = document.getElementById('ui-right');
            const minBtnRight = document.getElementById('minimize-btn-right');
            minBtnRight.onclick = () => {
                uiRight.classList.toggle('minimized');
                minBtnRight.textContent = uiRight.classList.contains('minimized') ? "➔" : "M";
            };

            // Minimap toggle
            const minimapToggleBtn = document.getElementById('minimapToggle');
            if (minimapToggleBtn) {
                minimapToggleBtn.onclick = () => {
                    minimapMode = minimapMode === 'heatmap' ? 'curve' : 'heatmap';
                    minimapToggleBtn.textContent = minimapMode === 'heatmap' ? '2D Map' : '1D Curve';
                    drawMinimap();
                };
            }
        }

        // ==================== MINIMAP DRAGGING ====================
        function setupMinimapDragging() {
            const minimapContainer = document.querySelector('#minimap')?.parentElement;
            if (!minimapContainer) return;

            minimapContainer.addEventListener('mousedown', (e) => {
                // Only start dragging if click is on the toggle button or minimap area
                if (e.target.id === 'minimapToggle' || e.target.id === 'minimap') {
                    isDraggingMinimap = true;
                    minimapDragOffsetX = e.clientX - minimapContainer.offsetLeft;
                    minimapDragOffsetY = e.clientY - minimapContainer.offsetTop;
                    minimapContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingMinimap) return;
                
                const minimapContainer = document.querySelector('#minimap')?.parentElement;
                if (!minimapContainer) return;

                const newX = e.clientX - minimapDragOffsetX;
                const newY = e.clientY - minimapDragOffsetY;

                // Constrain to window bounds
                const constrainedX = Math.max(0, Math.min(newX, window.innerWidth - minimapContainer.offsetWidth));
                const constrainedY = Math.max(0, Math.min(newY, window.innerHeight - minimapContainer.offsetHeight));

                minimapContainer.style.position = 'fixed';
                minimapContainer.style.bottom = 'auto';
                minimapContainer.style.right = 'auto';
                minimapContainer.style.left = constrainedX + 'px';
                minimapContainer.style.top = constrainedY + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDraggingMinimap) {
                    isDraggingMinimap = false;
                    const minimapContainer = document.querySelector('#minimap')?.parentElement;
                    if (minimapContainer) {
                        minimapContainer.style.cursor = 'grab';
                    }
                }
            });

            // Add grab cursor styling
            minimapContainer.style.cursor = 'grab';
        }

        // ==================== HAMBURGER TOGGLE & PREFERENCE ====================
        function setupHamburgerToggle() {
            const btn = document.getElementById('ui-right-hamburger');
            const panel = document.getElementById('ui-right');
            const minBtnRight = document.getElementById('minimize-btn-right');
            if (!btn || !panel) return;

            btn.addEventListener('click', () => {
                panel.classList.toggle('minimized');
                if (minBtnRight) minBtnRight.textContent = panel.classList.contains('minimized') ? "➔" : "M";
            });

            // initialize from saved preference
            const pref = localStorage.getItem('uiRightDefault') || 'open';
            const sel = document.getElementById('uiRightDefault');
            if (sel) sel.value = pref;
            if (pref === 'closed') {
                panel.classList.add('minimized');
                if (minBtnRight) minBtnRight.textContent = "➔";
            } else {
                panel.classList.remove('minimized');
                if (minBtnRight) minBtnRight.textContent = "M";
            }

            // save preference
            const saveBtn = document.getElementById('saveUiRightPref');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const v = document.getElementById('uiRightDefault')?.value || 'open';
                    localStorage.setItem('uiRightDefault', v);
                    showStatus('Right panel preference saved', 1500);
                });
            }
        }

        // ==================== CONSOLE FUNCTIONALITY ====================
        function initConsole() {
            // Toggle console with header click
            document.querySelector('.console-header').addEventListener('click', toggleConsole);
            
            // Wire up console buttons
            setupConsoleControls();
            
            // Initial update of statistics
            updateStatistics();
        }

        function toggleConsole() {
            const consolePanel = document.getElementById('console-panel');
            const minBtn = document.getElementById('minimize-btn-console');
            
            consolePanel.classList.toggle('minimized');
            consoleMinimized = consolePanel.classList.contains('minimized');
            minBtn.textContent = consoleMinimized ? "▲" : "▼";
        }

        function setupConsoleControls() {
            // Evaluate button
            const evalBtn = document.getElementById('eval-btn');
            if (evalBtn) {
                evalBtn.onclick = evaluatePoint;
            }
            
            // Enter key evaluation
            ['console-x', 'console-z'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') evaluatePoint();
                    });
                }
            });
            
            // Clear results button
            const clearBtn = document.getElementById('clear-results');
            if (clearBtn) {
                clearBtn.onclick = () => {
                    document.getElementById('console-results').innerHTML = '';
                    addConsoleResult('Cleared all results', '', '#888');
                };
            }
            
            // Export data button
            const exportBtn = document.getElementById('export-data');
            if (exportBtn) {
                exportBtn.onclick = exportConsoleData;
            }
            
            // Calculation buttons
            document.getElementById('calc-derivative')?.addEventListener('click', () => calculateDerivative('x'));
            document.getElementById('calc-derivative-z')?.addEventListener('click', () => calculateDerivative('z'));
            document.getElementById('calc-gradient')?.addEventListener('click', calculateGradient);
            document.getElementById('calc-double-int')?.addEventListener('click', calculateDoubleIntegral);
            document.getElementById('calc-triple-int')?.addEventListener('click', calculateTripleIntegral);
            document.getElementById('calc-volume')?.addEventListener('click', calculateVolume);
        }

        function evaluatePoint() {
            try {
                const xInput = document.getElementById('console-x');
                const zInput = document.getElementById('console-z');
                
                if (!xInput || !zInput) return;
                
                const x = parseFloat(xInput.value);
                const z = parseFloat(zInput.value);
                
                if (isNaN(x) || isNaN(z)) {
                    showStatus('Please enter valid numbers for x and z', 2000);
                    return;
                }
                
                const y = safeEval(x, z);
                const resultsDiv = document.getElementById('console-results');
                
                // Add result entry
                const entry = document.createElement('div');
                entry.className = 'console-entry';
                entry.innerHTML = `
                    <span style="color: #4ade80;">f(${x.toFixed(3)}, ${z.toFixed(3)})</span>
                    <span style="color: #ccc;"> = </span>
                    <span style="color: #ffaa44;">${y.toFixed(6)}</span>
                    <span style="color: #888; font-size: 0.7em; float: right;">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                `;
                
                resultsDiv.prepend(entry);
                
                // Limit number of entries
                const entries = resultsDiv.getElementsByClassName('console-entry');
                if (entries.length > 20) {
                    resultsDiv.removeChild(entries[entries.length - 1]);
                }
                
                // Scroll to top
                resultsDiv.scrollTop = 0;
                
                showStatus(`Evaluated: f(${x.toFixed(2)}, ${z.toFixed(2)}) = ${y.toFixed(4)}`, 1500);
                
            } catch (e) {
                console.error('Evaluation error:', e);
                showStatus('Error evaluating point: ' + e.message, 3000);
            }
        }

        function calculateDerivative(variable) {
            const xInput = document.getElementById('console-x');
            const zInput = document.getElementById('console-z');
            
            if (!xInput || !zInput) return;
            
            const x = parseFloat(xInput.value);
            const z = parseFloat(zInput.value);
            
            if (isNaN(x) || isNaN(z)) {
                showStatus('Please enter valid numbers first', 2000);
                return;
            }
            
            const h = 0.0001;
            let derivative;
            if (variable === 'x') {
                derivative = (safeEval(x + h, z) - safeEval(x - h, z)) / (2 * h);
            } else {
                derivative = (safeEval(x, z + h) - safeEval(x, z - h)) / (2 * h);
            }
            
            addConsoleResult(
                `∂f/∂${variable} at (${x.toFixed(2)}, ${z.toFixed(2)})`,
                derivative.toFixed(6),
                '#60a5fa'
            );
        }

        function calculateGradient() {
            const xInput = document.getElementById('console-x');
            const zInput = document.getElementById('console-z');
            
            if (!xInput || !zInput) return;
            
            const x = parseFloat(xInput.value);
            const z = parseFloat(zInput.value);
            
            if (isNaN(x) || isNaN(z)) {
                showStatus('Please enter valid numbers first', 2000);
                return;
            }
            
            const h = 0.0001;
            const df_dx = (safeEval(x + h, z) - safeEval(x - h, z)) / (2 * h);
            const df_dz = (safeEval(x, z + h) - safeEval(x, z - h)) / (2 * h);
            
            const magnitude = Math.sqrt(df_dx * df_dx + df_dz * df_dz);
            
            addConsoleResult(
                `∇f at (${x.toFixed(2)}, ${z.toFixed(2)})`,
                `<${df_dx.toFixed(4)}, ${df_dz.toFixed(4)}> (mag: ${magnitude.toFixed(4)})`,
                '#8b5cf6'
            );
        }

        function calculateDoubleIntegral() {
            const size = 10;
            const resolution = 50;
            const step = (size * 2) / resolution;
            
            let total = 0;
            let sampleCount = 0;
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + j * step + step / 2;
                    const y = safeEval(x, z);
                    
                    total += y * (step * step);
                    sampleCount++;
                }
            }
            
            const result = total;
            
            addConsoleResult(
                'Double Integral ∬ f(x,z) dxdz',
                result.toFixed(6),
                '#10b981'
            );
            
            showStatus(`Approximated double integral: ${result.toFixed(4)} (${sampleCount} samples)`, 2500);
        }

        function calculateTripleIntegral() {
            const size = 10;
            const xyResolution = 40;
            const yResolution = 20;
            
            const stepXZ = (size * 2) / xyResolution;
            let totalVolume = 0;
            
            for (let i = 0; i < xyResolution; i++) {
                for (let j = 0; j < xyResolution; j++) {
                    const x = -size + i * stepXZ + stepXZ / 2;
                    const z = -size + j * stepXZ + stepXZ / 2;
                    const height = safeEval(x, z);
                    
                    if (height > 0) {
                        const stepY = height / yResolution;
                        for (let k = 0; k < yResolution; k++) {
                            const y = (k + 0.5) * stepY;
                            totalVolume += stepXZ * stepXZ * stepY;
                        }
                    }
                }
            }
            
            addConsoleResult(
                'Triple Integral ∭ f(x,z) dV',
                totalVolume.toFixed(6),
                '#f59e0b'
            );
        }

        function calculateVolume() {
            const size = 10;
            const resolution = 100;
            
            // Method 1: Riemann sum
            let riemannVolume = 0;
            const step = (size * 2) / resolution;
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + j * step + step / 2;
                    const height = Math.abs(safeEval(x, z));
                    riemannVolume += height * step * step;
                }
            }
            
            // Method 2: Shell method approximation
            let shellVolume = 0;
            const shellStep = size / resolution;
            
            for (let r = 0; r < resolution; r++) {
                const radius = (r + 0.5) * shellStep;
                const circumference = 2 * Math.PI * radius;
                
                let totalHeight = 0;
                for (let theta = 0; theta < 8; theta++) {
                    const angle = (theta / 8) * Math.PI * 2;
                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    totalHeight += Math.abs(safeEval(x, z));
                }
                const avgHeight = totalHeight / 8;
                
                shellVolume += circumference * avgHeight * shellStep;
            }
            
            addConsoleResult(
                'Volume (Riemann)',
                riemannVolume.toFixed(6),
                '#ef4444'
            );
            
            addConsoleResult(
                'Volume (Shell Method)',
                shellVolume.toFixed(6),
                '#ec4899'
            );
            
            const diff = Math.abs(riemannVolume - shellVolume);
            const percentDiff = (diff / ((riemannVolume + shellVolume) / 2)) * 100;
            
            addConsoleResult(
                'Difference',
                `${diff.toFixed(6)} (${percentDiff.toFixed(2)}%)`,
                '#6b7280'
            );
        }

        function exportConsoleData() {
            const data = {
                function: document.getElementById('funcInput').value,
                evaluations: evalHistory,
                timestamp: new Date().toISOString(),
                mode: currentMode
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `calculus-console-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            
            showStatus('Data exported successfully', 2000);
            addConsoleResult('Exported console data', 'Download started', '#10b981');
        }

        function updateStatistics() {
            const size = 10;
            const resolution = 50;
            const step = (size * 2) / resolution;
            
            let minY = Infinity;
            let maxY = -Infinity;
            let totalY = 0;
            let sampleCount = 0;
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + j * step + step / 2;
                    const y = safeEval(x, z);
                    
                    if (isFinite(y)) {
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        totalY += y;
                        sampleCount++;
                    }
                }
            }
            
            const avgY = sampleCount > 0 ? totalY / sampleCount : 0;
            
            // Update statistics display
            document.getElementById('min-value').textContent = minY.toFixed(2);
            document.getElementById('max-value').textContent = maxY.toFixed(2);
            document.getElementById('avg-value').textContent = avgY.toFixed(4);
            document.getElementById('sample-count').textContent = sampleCount;
            
            // Update current function display
            const func = document.getElementById('funcInput').value;
            const shortFunc = func.length > 30 ? func.substring(0, 27) + '...' : func;
            document.getElementById('current-func').textContent = shortFunc;
            
            // Update mode display
            const modeNames = {
                'normal': 'Surface',
                'deriv': 'Partial Derivative',
                'double': 'Double Integral',
                'triple': 'Triple Integral',
                'shell': 'Shell Method'
            };
            document.getElementById('current-mode').textContent = modeNames[currentMode] || currentMode;
        }

        function addConsoleResult(label, value, color = '#ffaa44') {
            const resultsDiv = document.getElementById('console-results');
            const entry = document.createElement('div');
            entry.className = 'console-entry';
            entry.innerHTML = `
                <span style="color: #ccc;">${label}: </span>
                <span style="color: ${color};">${value}</span>
                <span style="color: #888; font-size: 0.7em; float: right;">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            `;
            
            resultsDiv.prepend(entry);
            
            const entries = resultsDiv.getElementsByClassName('console-entry');
            if (entries.length > 20) {
                resultsDiv.removeChild(entries[entries.length - 1]);
            }
            
            resultsDiv.scrollTop = 0;
        }

        // ==================== UTILITY FUNCTIONS ====================
        function setupSlider(sliderId, labelId, callback, isFloat = false) {
            const slider = document.getElementById(sliderId);
            const label = document.getElementById(labelId);
            if (!slider || !label) return;

            const value = isFloat ? parseFloat(slider.value).toFixed(2) : slider.value;
            label.textContent = value;
            
            slider.addEventListener('input', () => {
                const v = isFloat ? parseFloat(slider.value).toFixed(2) : slider.value;
                label.textContent = v;
                callback();
            });
        }

        function syncPresetSelection() {
            const funcInput = document.getElementById('funcInput');
            const preset = document.getElementById('presetSelect');
            if (!preset || !funcInput) return;

            const val = funcInput.value.trim();
            let matched = false;
            for (let i = 0; i < preset.options.length; i++) {
                if (preset.options[i].value === val) {
                    preset.selectedIndex = i;
                    matched = true;
                    break;
                }
            }
            if (!matched) preset.selectedIndex = 0;
        }

        function safeEval(x, z) {
            try {
                const expr = document.getElementById('funcInput').value;
                const fn = new Function('x', 'z', 'Math', `return (${expr});`);
                const result = fn(x, z, Math);
                
                // Store in history
                evalHistory.push({x, z, result, timestamp: Date.now()});
                if (evalHistory.length > 100) {
                    evalHistory.shift();
                }
                
                return (typeof result === 'number' && isFinite(result)) ? result : 0;
            } catch (e) {
                console.warn('safeEval error:', e);
                showStatus('Math error in function', 2000);
                return 0;
            }
        }

        function disposeObject(obj) {
            if (!obj) return;
            
            if (obj.children && obj.children.length > 0) {
                obj.children.forEach(child => {
                    disposeObject(child);
                });
            }
            
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => {
                        if (material.map) material.map.dispose();
                        material.dispose();
                    });
                } else {
                    if (obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
            }
            
            if (obj.parent) {
                obj.parent.remove(obj);
            }
        }

        function showStatus(msg, ms = 1800) {
            let el = document.getElementById('status');
            if (!el) return;
            el.textContent = msg;
            el.style.opacity = '1';
            if (statusTimer) clearTimeout(statusTimer);
            statusTimer = setTimeout(() => { el.style.opacity = '0'; }, ms);
        }

        // ==================== USER INPUT HANDLING ====================
        function onMouseDown(e) { 
            if (!mouseCameraEnabled) return;
            if (e.target.tagName === 'CANVAS') { 
                isMouseDown = true; 
                prevMouseX = e.clientX; 
                prevMouseY = e.clientY; 
            } 
        }

        function onMouseMove(e) {
            if (!isMouseDown || !mouseCameraEnabled) return;
            theta -= (e.clientX - prevMouseX) * 0.005;
            phi -= (e.clientY - prevMouseY) * 0.005;
            prevMouseX = e.clientX; 
            prevMouseY = e.clientY;
            updateCamera();
        }

        function onMouseUp() { 
            isMouseDown = false; 
        }

        function onWheel(e) { 
            e.preventDefault(); 
            radius = Math.max(5, Math.min(150, radius + e.deltaY * 0.01)); 
            updateCamera(); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Adjust minimap position based on console state
            const minimap = document.getElementById('minimap');
            const minimapContainer = minimap.parentElement;
            if (consoleMinimized) {
                minimapContainer.style.bottom = '80px';
            } else {
                minimapContainer.style.bottom = '50px';
            }
        }

        function handleInput() {
            const cameraLock2D = document.getElementById('cameraLock2D');
            const cameraLockFront = document.getElementById('cameraLockFront');
            const cameraLockSide = document.getElementById('cameraLockSide');
            if ((cameraLock2D?.checked) || (cameraLockFront?.checked) || (cameraLockSide?.checked)) {
                return;
            }

            let moved = false;
            if (keys['KeyW']) { phi -= 0.03; moved = true; }
            if (keys['KeyS']) { phi += 0.03; moved = true; }
            if (keys['KeyA']) { theta -= 0.03; moved = true; }
            if (keys['KeyD']) { theta += 0.03; moved = true; }
            if (moved) updateCamera();
        }

        // ==================== MODE & GRAPH MANAGEMENT ====================
        function setMode(mode) {
            currentMode = mode;
            sweepAngle = 0;
            document.querySelectorAll('button.mode-btn').forEach(b => b.classList.remove('active'));
            
            const btnId = 'btn' + mode.charAt(0).toUpperCase() + mode.slice(1);
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');
            
            updateGraph();
        }

        function updateGraph() {
            // Clean up previous objects properly
            if (graphObject) {
                try {
                    disposeObject(graphObject);
                } catch (e) {
                    console.warn('Error disposing graphObject:', e);
                }
                graphObject = null;
            }
            
            if (volumeObject) {
                try {
                    disposeObject(volumeObject);
                } catch (e) {
                    console.warn('Error disposing volumeObject:', e);
                }
                volumeObject = null;
            }
            
            const size = 10, res = 30;
            const logicText = document.getElementById('logicText');
            const formula = document.getElementById('formula');

            switch(currentMode) {
                case 'normal':
                    logicText.innerText = "Surface Visualization";
                    formula.innerHTML = "y = f(x, z)";
                    createSurface(size, res);
                    break;
                case 'deriv':
                    logicText.innerText = "Partial Derivative ∂f/∂x";
                    formula.innerHTML = "y = [f(x+h, z) - f(x, z)] / h";
                    createSurface(size, res, 'deriv');
                    break;
                case 'double':
                    logicText.innerText = "Double Integral (Signed Area)";
                    formula.innerHTML = "V = ∫∫ f(x, z) dx dz";
                    createSurface(size, res);
                    createVolume(size, res);
                    break;
                case 'triple':
                    logicText.innerText = "Triple Integral (Volume Under Surface)";
                    formula.innerHTML = "V = ∫∫ f(x, z) dA";
                    const triEl = document.getElementById('tripleRes');
                    const triRes = triEl ? parseInt(triEl.value) : 24;
                    createVolumetricCloud(size, triRes);
                    break;
                case 'shell':
                    logicText.innerText = "Cylindrical Shells (Washer Method)";
                    formula.innerHTML = "V = ∫ 2π r h(r) dr";
                    createShells(size, 20);
                    break;
            }

            drawMinimap();
            updateStatistics();
        }

        // ==================== GRAPH CREATION FUNCTIONS ====================
        function createSurface(size, res, type = 'normal') {
            const geometry = new THREE.PlaneGeometry(size*2, size*2, res, res);
            geometry.rotateX(-Math.PI / 2);
            
            const pos = geometry.attributes.position;
            const h = 0.01;

            for (let i = 0; i < pos.count; i++) {
                let x = pos.getX(i);
                let z = pos.getZ(i);
                let y = 0;

                if (type === 'deriv') {
                    y = (safeEval(x + h, z) - safeEval(x - h, z)) / (2 * h);
                } else {
                    y = safeEval(x, z);
                }
                pos.setY(i, y);
            }
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                color: type === 'deriv' ? 0xff4444 : 0x00ff88,
                wireframe: true,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });

            graphObject = new THREE.Mesh(geometry, material);
            scene.add(graphObject);
        }
        
        function createVolume(size, res) {
            const group = new THREE.Group();
            const step = (size * 2) / res;
            
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const x = -size + i * step + step/2;
                    const z = -size + j * step + step/2;
                    const y = safeEval(x, z);
                    
                    if (Math.abs(y) < 0.01) continue;

                    const boxGeo = new THREE.BoxGeometry(step * 0.9, Math.abs(y), step * 0.9);
                    const boxMat = new THREE.MeshPhongMaterial({
                        color: 0x2563eb,
                        transparent: true,
                        opacity: 0.4
                    });
                    const box = new THREE.Mesh(boxGeo, boxMat);
                    box.position.set(x, y/2, z);
                    group.add(box);
                }
            }
            volumeObject = group;
            scene.add(volumeObject);
        }

        function createVolumetricCloud(size, res) {
            const step = (size * 2) / res;
            const points = [];
            const samplesPerUnit = 8;

            for (let i = 0; i < res; i++) {
                for (let k = 0; k < res; k++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + k * step + step / 2;
                    const density = safeEval(x, z);
                    if (!(density > 0)) continue;

                    const maxY = Math.min(density, size);
                    const numSamples = Math.max(2, Math.floor(density * samplesPerUnit));
                    for (let j = 0; j < numSamples; j++) {
                        const y = (j + 0.5) * (maxY / numSamples);
                        points.push({ x, y, z });
                    }
                }
            }

            if (points.length === 0) return;

            const pSizeEl = document.getElementById('particleSize');
            const pOpEl = document.getElementById('particleOpacity');
            const pSize = pSizeEl ? parseFloat(pSizeEl.value) : 0.08;
            const pOp = pOpEl ? parseFloat(pOpEl.value) : 0.6;
            
            const dotGeo = new THREE.SphereGeometry(pSize, 6, 6);
            const dotMat = new THREE.MeshBasicMaterial({ 
                color: 0x4ade80, 
                transparent: true, 
                opacity: pOp 
            });
            const instancedMesh = new THREE.InstancedMesh(dotGeo, dotMat, points.length);
            const dummy = new THREE.Object3D();

            points.forEach((p, i) => {
                dummy.position.set(p.x, p.y, p.z);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            });
            instancedMesh.instanceMatrix.needsUpdate = true;

            volumeObject = instancedMesh;
            scene.add(volumeObject);
        }

        function createShells(size, res, angle = Math.PI * 2) {
            const group = new THREE.Group();
            const step = size / res;
            const circumferenceSamples = 8;

            for (let i = 1; i <= res; i++) {
                const r = i * step;
                
                let heightSum = 0;
                for (let j = 0; j < circumferenceSamples; j++) {
                    const shellTheta = (j / circumferenceSamples) * Math.PI * 2;
                    const x = r * Math.cos(shellTheta);
                    const z = r * Math.sin(shellTheta);
                    heightSum += Math.abs(safeEval(x, z));
                }
                const height = heightSum / circumferenceSamples;
                
                if (height < 0.01) continue;

                const geo = new THREE.CylinderGeometry(r, r, height, 32, 1, true, 0, angle);
                const mat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(i / res, 0.8, 0.5),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });

                const shell = new THREE.Mesh(geo, mat);
                shell.position.set(0, height / 2, 0);
                group.add(shell);
            }

            volumeObject = group;
            scene.add(volumeObject);
        }

        // ==================== CAMERA CONTROL ====================
        function updateCamera() {
            const cameraLock2D = document.getElementById('cameraLock2D');
            const cameraLockFront = document.getElementById('cameraLockFront');
            const cameraLockSide = document.getElementById('cameraLockSide');
            
            if (cameraLock2D?.checked) {
                camera.position.set(0, 35, 0);
                camera.lookAt(0, 0, 0);
            } else if (cameraLockFront?.checked) {
                camera.position.set(0, 0, 35);
                camera.lookAt(0, 0, 0);
            } else if (cameraLockSide?.checked) {
                camera.position.set(35, 0, 0);
                camera.lookAt(0, 0, 0);
            } else {
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
                camera.lookAt(0, 0, 0);
            }
        }

        // ==================== MINIMAP RENDERING ====================
        function drawMinimap() {
            if (minimapMode === 'heatmap') {
                drawMinimapHeatmap();
            } else {
                drawMinimapCurve();
            }
        }

        function drawMinimapHeatmap() {
            const canvas = document.getElementById('minimap');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const size = 10, res = 40;
            const step = (size * 2) / res;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + j * step + step / 2;
                    const val = safeEval(x, z);
                    if (isFinite(val)) {
                        minVal = Math.min(minVal, val);
                        maxVal = Math.max(maxVal, val);
                    }
                }
            }

            if (!isFinite(minVal) || !isFinite(maxVal)) {
                minVal = -5;
                maxVal = 5;
            }

            const range = maxVal - minVal;
            const padding = range * 0.05;
            minVal -= padding;
            maxVal += padding;

            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const x = -size + i * step + step / 2;
                    const z = -size + j * step + step / 2;
                    const val = safeEval(x, z);
                    
                    let normalized = (val - minVal) / (maxVal - minVal);
                    normalized = Math.max(0, Math.min(1, normalized));
                    
                    let color = getHeatmapColor(normalized);
                    
                    ctx.fillStyle = color;
                    const canvasX = (i / res) * w;
                    const canvasY = (j / res) * h;
                    ctx.fillRect(canvasX, canvasY, w / res + 1, h / res + 1);
                }
            }

            drawMinimapGrid(ctx, w, h, res, 5);
            drawMinimapAxes(ctx, w, h);
            drawMinimapLegend(ctx, w, h, minVal, maxVal);
        }

        function drawMinimapCurve() {
            const canvas = document.getElementById('minimap');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const size = 10, res = 80;
            const step = (size * 2) / res;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i <= res; i++) {
                const x = -size + i * step;
                const y = safeEval(x, 0);
                if (isFinite(y)) {
                    minVal = Math.min(minVal, y);
                    maxVal = Math.max(maxVal, y);
                }
            }

            if (!isFinite(minVal) || !isFinite(maxVal)) {
                minVal = -5;
                maxVal = 5;
            }

            const range = maxVal - minVal;
            const padding = range * 0.1;
            minVal -= padding;
            maxVal += padding;

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= res; i += 10) {
                const x = (i / res) * w;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * h;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            const centerX = 0, centerY = h / 2;
            const scaleX = w / (size * 2);
            const scaleY = h / (maxVal - minVal);

            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2.5;
            ctx.beginPath();

            let first = true;
            for (let i = 0; i <= res; i++) {
                const x = -size + i * step;
                const y = safeEval(x, 0);
                
                const canvasX = centerX + (x + size) * scaleX;
                const canvasY = centerY - (y - minVal - (maxVal - minVal) / 2) * scaleY;

                if (first) {
                    ctx.moveTo(canvasX, canvasY);
                    first = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();

            const axisY = centerY + ((maxVal - minVal) / 2) * scaleY;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(w, axisY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX + size * scaleX, 0);
            ctx.lineTo(centerX + size * scaleX, h);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('X', w - 5, axisY - 5);
            ctx.textAlign = 'left';
            ctx.fillText('Y', centerX + size * scaleX + 3, 12);

            ctx.fillStyle = '#666';
            ctx.font = '8px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(maxVal.toFixed(1), 5, 10);
            ctx.fillText(minVal.toFixed(1), 5, h - 2);
        }

        function getHeatmapColor(normalized) {
            const hue = 240 * (1 - normalized);
            return `hsl(${hue}, 100%, 50%)`;
        }

        function drawMinimapGrid(ctx, w, h, res, interval) {
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= res; i += interval) {
                const x = (i / res) * w;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
                const y = (i / res) * h;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
        }

        function drawMinimapAxes(ctx, w, h) {
            const centerX = w / 2, centerY = h / 2;
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, h);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(w, centerY);
            ctx.stroke();

            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('X', w - 8, centerY - 8);
            ctx.textAlign = 'right';
            ctx.fillText('Z', centerX - 8, 14);
        }

        function drawMinimapLegend(ctx, w, h, minVal, maxVal) {
            const legWidth = 12, legHeight = 60;
            const legX = w - legWidth - 4, legY = h - legHeight - 4;
            for (let i = 0; i < legHeight; i++) {
                const normalized = 1 - (i / legHeight);
                let color = getHeatmapColor(normalized);
                ctx.fillStyle = color;
                ctx.fillRect(legX, legY + i, legWidth, 1);
            }

            ctx.fillStyle = '#888';
            ctx.font = '9px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(maxVal.toFixed(1), legX + legWidth + 2, legY - 2);
            ctx.fillText(minVal.toFixed(1), legX + legWidth + 2, legY + legHeight + 4);
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            handleInput();

            if (currentMode === 'shell') {
                const autoEl = document.getElementById('shellAuto');
                const speedEl = document.getElementById('shellSpeed');
                const speed = speedEl ? parseFloat(speedEl.value) : 0.05;
                const auto = autoEl ? autoEl.checked : true;
                
                if (auto) {
                    if (sweepAngle < Math.PI * 2) {
                        sweepAngle = Math.min(Math.PI * 2, sweepAngle + speed);
                        if (volumeObject && volumeObject.children.length > 0) {
                            updateShells(sweepAngle);
                        } else {
                            createShells(10, 20, sweepAngle);
                        }
                    }
                } else {
                    createShells(10, 20, Math.PI * 2);
                }
            } else {
                sweepAngle = 0;
            }

            renderer.render(scene, camera);
        }

        function updateShells(angle) {
            if (!volumeObject) return;
            
            volumeObject.children.forEach((shell, index) => {
                const r = (index + 1) * (10 / 20);
                const oldGeo = shell.geometry;
                
                const newGeo = new THREE.CylinderGeometry(r, r, 2, 32, 1, true, 0, angle);
                
                oldGeo.dispose();
                shell.geometry = newGeo;
            });
        }

        // ==================== STARTUP ====================
        window.onload = init;
    </script>
</body>
</html>
